
# ì ì‡ê¸° í¼ì¦ ìƒì„±ê¸° - ê¸°ìˆ  ì•„í‚¤í…ì²˜ ë¬¸ì„œ

**ë¬¸ì„œ ë²„ì „**: 2.0 (í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ)  
**ì‘ì„±ì¼**: 2025ë…„ 10ì›” 23ì¼  
**ëŒ€ìƒ ë…ì**: ê°œë°œíŒ€

---

## ëª©ì°¨

1. [ì‹œìŠ¤í…œ ê°œìš”](#1-ì‹œìŠ¤í…œ-ê°œìš”)
2. [ê¸°ìˆ  ìŠ¤íƒ](#2-ê¸°ìˆ -ìŠ¤íƒ)
3. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#3-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
4. [í”„ë¡ íŠ¸ì—”ë“œ ì•„í‚¤í…ì²˜](#4-í”„ë¡ íŠ¸ì—”ë“œ-ì•„í‚¤í…ì²˜)
5. [ì´ë¯¸ì§€ ì²˜ë¦¬ ì•Œê³ ë¦¬ì¦˜](#5-ì´ë¯¸ì§€-ì²˜ë¦¬-ì•Œê³ ë¦¬ì¦˜)
6. [ë°ì´í„° ëª¨ë¸](#6-ë°ì´í„°-ëª¨ë¸)
7. [ì„±ëŠ¥ ìµœì í™”](#7-ì„±ëŠ¥-ìµœì í™”)
8. [ë°°í¬ ì „ëµ](#8-ë°°í¬-ì „ëµ)
9. [í…ŒìŠ¤íŠ¸ ì „ëµ](#9-í…ŒìŠ¤íŠ¸-ì „ëµ)

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1. ì•„í‚¤í…ì²˜ ì›ì¹™

**ì™„ì „ í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ì²˜ë¦¬**
- ëª¨ë“  ì´ë¯¸ì§€ ì²˜ë¦¬ê°€ ì‚¬ìš©ì ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤í–‰
- ì„œë²„ë¡œ ì´ë¯¸ì§€ ì „ì†¡ ì—†ìŒ (í”„ë¼ì´ë²„ì‹œ ë³´ì¥)
- ì„œë²„ëŠ” ì •ì  íŒŒì¼ë§Œ ì œê³µ (Next.js + Vercel)

**ì£¼ìš” íŠ¹ì§•**
- ğŸš€ ë¹ ë¥¸ ì²˜ë¦¬ (ë„¤íŠ¸ì›Œí¬ ì™•ë³µ ì—†ìŒ)
- ğŸ’° ë¬´ë£Œ ìš´ì˜ (ì„œë²„ ë¹„ìš© 0)
- ğŸ”’ í”„ë¼ì´ë²„ì‹œ (ì´ë¯¸ì§€ê°€ ì„œë²„ì— ì €ì¥ ì•ˆë¨)
- ğŸ“± í™•ì¥ ê°€ëŠ¥ (CDNì„ í†µí•œ ë¬´í•œ í™•ì¥)

### 1.2. ì‹œìŠ¤í…œ êµ¬ì„±ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ì‚¬ìš©ì ë¸Œë¼ìš°ì €                      â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Next.js 15 í´ë¼ì´ì–¸íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜    â”‚ â”‚
â”‚  â”‚  (React 19, Turbopack)               â”‚ â”‚
â”‚  â”‚                                       â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  React Components (ë©”ì¸ ìŠ¤ë ˆë“œ)  â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - ImageUploader                â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - EditorPanel                  â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - PuzzlePreview                â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - DownloadButton               â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚            â†• postMessage             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  Web Worker (ë³„ë„ ìŠ¤ë ˆë“œ)        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - OffscreenCanvas              â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - Canny ì—£ì§€ ê²€ì¶œ              â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - ìœ¤ê³½ì„  ì¶”ì¶œ                   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - ì  ë°°ì¹˜ ì•Œê³ ë¦¬ì¦˜              â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚                                       â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  ìƒíƒœ ê´€ë¦¬ (Zustand)            â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - imageStore                   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  - puzzleStore                  â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ HTTPS
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Vercel Edge Network â”‚
        â”‚   (ì •ì  íŒŒì¼ CDN)      â”‚
        â”‚                       â”‚
        â”‚   - HTML/CSS/JS       â”‚
        â”‚   - ì´ë¯¸ì§€/í°íŠ¸        â”‚
        â”‚   - ì„œë²„ ë¡œì§ ì—†ìŒ     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ê¸°ìˆ  ìŠ¤íƒ

### 2.1. ì½”ì–´ í”„ë ˆì„ì›Œí¬

```yaml
Framework:
  - Next.js: 15.x (App Router, Turbopack)
  - React: 19.x
  - TypeScript: 5.7.x

Styling:
  - Tailwind CSS: 4.x
  - shadcn/ui: latest
  - Radix UI: latest

State Management:
  - Zustand: 4.5.x

Build Tools:
  - Turbopack: (Next.js 15 ê¸°ë³¸)
  - PostCSS: 8.4.0
```

### 2.2. ì´ë¯¸ì§€ ì²˜ë¦¬

```yaml
Native Browser APIs:
  - Canvas API: ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ë° í”½ì…€ ì¡°ì‘
  - ImageData API: í”½ì…€ ë°ì´í„° ì§ì ‘ ì ‘ê·¼
  - File API: íŒŒì¼ ì½ê¸°
  - Blob API: íŒŒì¼ ë‹¤ìš´ë¡œë“œ

Worker APIs (with fallback):
  - OffscreenCanvas: Workerì—ì„œ Canvas ì‚¬ìš© (í´ë°±: ë©”ì¸ ìŠ¤ë ˆë“œ)
  - createImageBitmap: Workerì—ì„œ ì´ë¯¸ì§€ ë¡œë“œ (í´ë°±: ë©”ì¸ ìŠ¤ë ˆë“œ)

Optional Libraries (Phase 2):
  - jsPDF: 2.5.0 (PDF ìƒì„±)
  - file-saver: 2.0.5 (íŒŒì¼ ë‹¤ìš´ë¡œë“œ í—¬í¼)
```

**âš ï¸ ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ë¦¬ìŠ¤í¬**:
- iOS Safari 15.x ì´í•˜: Workerì—ì„œ OffscreenCanvas ë¯¸ì§€ì›
- Safari 16.0-16.3: createImageBitmap ë¶€ë¶„ ì§€ì›
- **ì˜í–¥**: iPad/iPhone ì‚¬ìš©ì (ì£¼ íƒ€ê²Ÿì¸µ) ìƒì„± ì‹¤íŒ¨ ê°€ëŠ¥

**í•´ê²° ì „ëµ**:
- Feature detectionìœ¼ë¡œ ì§€ì› ì—¬ë¶€ í™•ì¸
- ë¯¸ì§€ì› ì‹œ ë©”ì¸ ìŠ¤ë ˆë“œ í´ë°± (UIëŠ” ëŠë ¤ë„ ë™ì‘ì€ ë³´ì¥)
- ì„±ëŠ¥ ì €í•˜ ê²½ê³  ë©”ì‹œì§€ í‘œì‹œ

### 2.3. í”„ë ˆì„ì›Œí¬ ìŠ¤íƒ ë¦¬ìŠ¤í¬ ë° ì™„í™”

**âš ï¸ Next.js 15/React 19 ì‚¬ìš© ë¦¬ìŠ¤í¬**:

```yaml
ë¦¬ìŠ¤í¬:
  - Next.js 15: RC ë‹¨ê³„, í”„ë¡œë•ì…˜ ì•ˆì •ì„± ë¯¸ê²€ì¦
  - React 19: shadcn/ui, Radix UI ì¼ë¶€ í˜¸í™˜ì„± ì´ìŠˆ ê°€ëŠ¥
  - Tailwind 4: Beta, í”ŒëŸ¬ê·¸ì¸ ìƒíƒœê³„ ë¯¸ì„±ìˆ™
  - Turbopack: Webpack ëŒ€ë¹„ í”ŒëŸ¬ê·¸ì¸ ì œí•œ

ì¼ì • ì˜í–¥:
  - í˜¸í™˜ì„± ë””ë²„ê¹…: ì˜ˆìƒ 1-3ì¼ ì¶”ê°€ ì†Œìš” ê°€ëŠ¥
  - ì˜ì¡´ì„± ë²„ì „ ì¶©ëŒ: shadcn/ui ì„¤ì¹˜ ì‹¤íŒ¨ ê°€ëŠ¥
```

**ì™„í™” ì „ëµ**:

1. **ì¦‰ì‹œ ë¡¤ë°± ì¤€ë¹„**
   ```bash
   # ë¬¸ì œ ë°œìƒ ì‹œ ì¦‰ì‹œ Next.js 14ë¡œ ë¡¤ë°±
   pnpm install next@14.2.15 react@18.3.1 react-dom@18.3.1
   ```

2. **UI ë¼ì´ë¸ŒëŸ¬ë¦¬ ëŒ€ì•ˆ**
   - shadcn/ui ì‹¤íŒ¨ ì‹œ â†’ Headless UI + Tailwind ì§ì ‘ ìŠ¤íƒ€ì¼ë§
   - ì»´í¬ë„ŒíŠ¸ 3ê°œë§Œ í•„ìš”: Button, Slider, Card

3. **ë‹¨ê³„ì  ê²€ì¦**
   - Day 1: í”„ë¡œì íŠ¸ ìƒì„± í›„ ì¦‰ì‹œ ë¹Œë“œ í…ŒìŠ¤íŠ¸
   - ë¹Œë“œ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ Next.js 14ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
   - shadcn/ui ì„¤ì¹˜ ì‹¤íŒ¨ ì‹œ ëŒ€ì•ˆ UI ì‚¬ìš©

4. **ìµœëŒ€ ë¦¬ìŠ¤í¬ í—ˆìš© ì‹œê°„**
   - Day 1 ì¢…ë£Œ ì‹œì ê¹Œì§€ í™˜ê²½ êµ¬ì¶• ì™„ë£Œ í•„ìˆ˜
   - ë¬¸ì œ ì§€ì† ì‹œ Day 2ë¶€í„° Next.js 14ë¡œ ì‘ì—…

### 2.4. ê°œë°œ ë„êµ¬

```yaml
Code Quality:
  - ESLint: 8.0.0
  - Prettier: 3.0.0
  - TypeScript: 5.3.0

Testing:
  - Vitest: 1.0.0 (ë‹¨ìœ„ í…ŒìŠ¤íŠ¸)
  - Playwright: 1.40.0 (E2E í…ŒìŠ¤íŠ¸)

Development:
  - pnpm: 8.0.0 (íŒ¨í‚¤ì§€ ê´€ë¦¬)
  - Git: ë²„ì „ ê´€ë¦¬
```

### 2.4. ë°°í¬ ë° ëª¨ë‹ˆí„°ë§

```yaml
Hosting:
  - Vercel: Edge Network ë°°í¬

Analytics:
  - Vercel Analytics: ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  - Google Analytics 4: ì‚¬ìš©ì í–‰ë™ ë¶„ì„ (ì„ íƒ)

Error Tracking:
  - Sentry: ì—ëŸ¬ ì¶”ì  (ì„ íƒ)
```

---

## 3. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 3.1. ë°ì´í„° íë¦„

```
[ì‚¬ìš©ì] â†’ [ì´ë¯¸ì§€ ì„ íƒ] â†’ [File ê°ì²´]
                                  â”‚
                                  â–¼
                        [FileReader API]
                                  â”‚
                                  â–¼
                        [Image ê°ì²´ ìƒì„±]
                                  â”‚
                                  â–¼
                        [Canvasì— ê·¸ë¦¬ê¸°]
                                  â”‚
                                  â–¼
                        [ImageData ì¶”ì¶œ]
                                  â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â–¼                                   â–¼
        [ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜]                [í¬ê¸° ì¡°ì •]
                â”‚                                   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â–¼
                        [ì—£ì§€ ê²€ì¶œ (Sobel)]
                                  â”‚
                                  â–¼
                        [ì´ì§„í™” (Threshold)]
                                  â”‚
                                  â–¼
                        [ìœ¤ê³½ì„  ì¶”ì¶œ]
                                  â”‚
                                  â–¼
                [Douglas-Peucker ì•Œê³ ë¦¬ì¦˜]
                                  â”‚
                                  â–¼
                        [ì  í•„í„°ë§ (ìµœì†Œ ê±°ë¦¬)]
                                  â”‚
                                  â–¼
                        [ë²ˆí˜¸ ë§¤ê¸°ê¸°]
                                  â”‚
                                  â–¼
                        [ì  ë°ì´í„° ë°°ì—´]
                                  â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â–¼                                   â–¼
        [Canvas ë¯¸ë¦¬ë³´ê¸°]                    [PNG ìƒì„±]
                                                  â”‚
                                                  â–¼
                                            [ë‹¤ìš´ë¡œë“œ]
```

### 3.2. ì»´í¬ë„ŒíŠ¸ ê³„ì¸µ êµ¬ì¡°

```
App Layout
â””â”€â”€ HomePage (/)
    â””â”€â”€ ImageUploader
        â””â”€â”€ DropZone

App Layout
â””â”€â”€ EditorPage (/editor)
    â”œâ”€â”€ OriginalImagePanel
    â”‚   â”œâ”€â”€ ImagePreview
    â”‚   â””â”€â”€ ChangeImageButton
    â”œâ”€â”€ ControlPanel
    â”‚   â”œâ”€â”€ DifficultySlider
    â”‚   â”œâ”€â”€ StartPositionSelector
    â”‚   â””â”€â”€ GenerateButton
    â””â”€â”€ ResultPanel
        â”œâ”€â”€ LoadingSpinner
        â”œâ”€â”€ PuzzlePreview (Canvas)
        â””â”€â”€ DownloadButton
```

---

## 4. í”„ë¡ íŠ¸ì—”ë“œ ì•„í‚¤í…ì²˜

### 4.1. í”„ë¡œì íŠ¸ êµ¬ì¡°

```
connect-the-dots/
â”œâ”€â”€ app/                                # Next.js 15 App Router
â”‚   â”œâ”€â”€ layout.tsx                      # ë£¨íŠ¸ ë ˆì´ì•„ì›ƒ
â”‚   â”œâ”€â”€ page.tsx                        # í™ˆí˜ì´ì§€ (ì—…ë¡œë“œ)
â”‚   â”œâ”€â”€ editor/
â”‚   â”‚   â””â”€â”€ page.tsx                    # í¸ì§‘ í˜ì´ì§€
â”‚   â”œâ”€â”€ guides/
â”‚   â”‚   â””â”€â”€ page.tsx                    # ê°€ì´ë“œ í˜ì´ì§€
â”‚   â””â”€â”€ globals.css                     # ì „ì—­ ìŠ¤íƒ€ì¼
â”‚
â”œâ”€â”€ components/                         # React ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ ui/                            # shadcn/ui ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ button.tsx
â”‚   â”‚   â”œâ”€â”€ slider.tsx
â”‚   â”‚   â”œâ”€â”€ card.tsx
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â””â”€â”€ Footer.tsx
â”‚   â”œâ”€â”€ upload/
â”‚   â”‚   â”œâ”€â”€ ImageUploader.tsx
â”‚   â”‚   â”œâ”€â”€ DropZone.tsx
â”‚   â”‚   â””â”€â”€ ImagePreview.tsx
â”‚   â”œâ”€â”€ editor/
â”‚   â”‚   â”œâ”€â”€ ControlPanel.tsx
â”‚   â”‚   â”œâ”€â”€ DifficultySlider.tsx
â”‚   â”‚   â”œâ”€â”€ StartPositionSelector.tsx
â”‚   â”‚   â””â”€â”€ GenerateButton.tsx
â”‚   â”œâ”€â”€ preview/
â”‚   â”‚   â”œâ”€â”€ PuzzleCanvas.tsx
â”‚   â”‚   â””â”€â”€ DownloadButton.tsx
â”‚   â””â”€â”€ common/
â”‚       â”œâ”€â”€ LoadingSpinner.tsx
â”‚       â””â”€â”€ ErrorMessage.tsx
â”‚
â”œâ”€â”€ lib/                               # í•µì‹¬ ë¡œì§
â”‚   â”œâ”€â”€ image-processing/              # ì´ë¯¸ì§€ ì²˜ë¦¬ ì—”ì§„ (Worker ì „ìš©)
â”‚   â”‚   â”œâ”€â”€ index.ts                   # ë©”ì¸ ì§„ì…ì 
â”‚   â”‚   â”œâ”€â”€ canvas-utils.ts            # Canvas ìœ í‹¸ë¦¬í‹°
â”‚   â”‚   â”œâ”€â”€ grayscale.ts               # ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
â”‚   â”‚   â”œâ”€â”€ edge-detection.ts          # Canny ì—£ì§€ ê²€ì¶œ
â”‚   â”‚   â”œâ”€â”€ contour-extraction.ts      # ìœ¤ê³½ì„  ì¶”ì¶œ
â”‚   â”‚   â”œâ”€â”€ point-placement.ts         # ì  ë°°ì¹˜
â”‚   â”‚   â”œâ”€â”€ numbering.ts               # ë²ˆí˜¸ ë§¤ê¸°ê¸°
â”‚   â”‚   â””â”€â”€ douglas-peucker.ts         # DP ì•Œê³ ë¦¬ì¦˜
â”‚   â”‚
â”‚   â”œâ”€â”€ output/                        # ì¶œë ¥ ìƒì„±
â”‚   â”‚   â”œâ”€â”€ png-generator.ts           # PNG ìƒì„±
â”‚   â”‚   â””â”€â”€ pdf-generator.ts           # PDF ìƒì„± (Phase 2)
â”‚   â”‚
â”‚   â””â”€â”€ utils/                         # ìœ í‹¸ë¦¬í‹°
â”‚       â”œâ”€â”€ validation.ts              # íŒŒì¼ ê²€ì¦
â”‚       â”œâ”€â”€ geometry.ts                # ê¸°í•˜í•™ ê³„ì‚°
â”‚       â””â”€â”€ constants.ts               # ìƒìˆ˜
â”‚
â”œâ”€â”€ workers/                           # Web Workers (MVP í•„ìˆ˜)
â”‚   â””â”€â”€ image-processor.worker.ts      # ì´ë¯¸ì§€ ì²˜ë¦¬ Worker
â”‚
â”œâ”€â”€ stores/                            # Zustand ìƒíƒœ ê´€ë¦¬
â”‚   â”œâ”€â”€ useImageStore.ts               # ì´ë¯¸ì§€ ìƒíƒœ
â”‚   â”œâ”€â”€ usePuzzleStore.ts              # í¼ì¦ ìƒíƒœ
â”‚   â””â”€â”€ useUIStore.ts                  # UI ìƒíƒœ
â”‚
â”œâ”€â”€ types/                             # TypeScript íƒ€ì…
â”‚   â”œâ”€â”€ image.ts
â”‚   â”œâ”€â”€ puzzle.ts
â”‚   â””â”€â”€ index.ts
â”‚
â””â”€â”€ hooks/                             # ì»¤ìŠ¤í…€ í›…
    â”œâ”€â”€ useImageUpload.ts
    â”œâ”€â”€ usePuzzleGeneration.ts         # Worker í†µì‹  ë˜í¼
    â””â”€â”€ useDownload.ts
â”‚
â”œâ”€â”€ public/                            # ì •ì  íŒŒì¼
â”‚   â”œâ”€â”€ examples/                      # ì˜ˆì‹œ ì´ë¯¸ì§€
â”‚   â”œâ”€â”€ icons/
â”‚   â””â”€â”€ fonts/
â”‚
â”œâ”€â”€ tests/                             # í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚
â”œâ”€â”€ package.json
â”œâ”€â”€ next.config.ts
â”œâ”€â”€ tailwind.config.ts
â”œâ”€â”€ tsconfig.json
â””â”€â”€ .env.local
```

### 4.2. Zustand ìƒíƒœ ê´€ë¦¬

#### 4.2.1. Image Store

```typescript
// stores/useImageStore.ts

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface ImageState {
  // ìƒíƒœ
  file: File | null;
  dataUrl: string | null;
  width: number;
  height: number;
  name: string;
  size: number;
  
  // ì•¡ì…˜
  setImage: (file: File) => Promise<void>;
  clearImage: () => void;
  
  // ê³„ì‚°ëœ ê°’
  isValid: boolean;
  isTooLarge: boolean;
}

export const useImageStore = create<ImageState>()(
  devtools(
    (set, get) => ({
      // ì´ˆê¸° ìƒíƒœ
      file: null,
      dataUrl: null,
      width: 0,
      height: 0,
      name: '',
      size: 0,
      
      // ì•¡ì…˜
      setImage: async (file: File) => {
        // Fileì„ Data URLë¡œ ë³€í™˜
        const dataUrl = await new Promise<string>((resolve) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target?.result as string);
          reader.readAsDataURL(file);
        });
        
        // ì´ë¯¸ì§€ í¬ê¸° í™•ì¸
        const img = new Image();
        await new Promise((resolve) => {
          img.onload = resolve;
          img.src = dataUrl;
        });
        
        set({
          file,
          dataUrl,
          width: img.width,
          height: img.height,
          name: file.name,
          size: file.size,
        });
      },
      
      clearImage: () => {
        set({
          file: null,
          dataUrl: null,
          width: 0,
          height: 0,
          name: '',
          size: 0,
        });
      },
      
      // ê³„ì‚°ëœ ê°’
      get isValid() {
        const { file, width, height } = get();
        return (
          file !== null &&
          width > 100 &&
          height > 100 &&
          width <= 2000 &&
          height <= 2000
        );
      },
      
      get isTooLarge() {
        const { size } = get();
        return size > 5 * 1024 * 1024; // 5MB
      },
    }),
    { name: 'ImageStore' }
  )
);
```

#### 4.2.2. Puzzle Store

```typescript
// stores/usePuzzleStore.ts

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

interface Point {
  x: number;
  y: number;
  number: number;
}

interface PuzzleState {
  // ì„¤ì •
  difficulty: number; // 0-100
  startPosition: 'top-left' | 'top-right' | 'center';
  
  // ìƒì„±ëœ ë°ì´í„°
  points: Point[];
  originalSize: { width: number; height: number };
  
  // ìƒíƒœ
  isGenerating: boolean;
  progress: number; // 0-100
  error: string | null;
  
  // ì•¡ì…˜
  setDifficulty: (difficulty: number) => void;
  setStartPosition: (position: 'top-left' | 'top-right' | 'center') => void;
  setPoints: (points: Point[], originalSize: { width: number; height: number }) => void;
  setGenerating: (isGenerating: boolean) => void;
  setProgress: (progress: number) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

export const usePuzzleStore = create<PuzzleState>()(
  devtools(
    (set) => ({
      // ì´ˆê¸° ìƒíƒœ
      difficulty: 50,
      startPosition: 'top-left',
      points: [],
      originalSize: { width: 0, height: 0 },
      isGenerating: false,
      progress: 0,
      error: null,
      
      // ì•¡ì…˜
      setDifficulty: (difficulty) => set({ difficulty }),
      setStartPosition: (startPosition) => set({ startPosition }),
      setPoints: (points, originalSize) => set({ points, originalSize }),
      setGenerating: (isGenerating) => set({ isGenerating }),
      setProgress: (progress) => set({ progress }),
      setError: (error) => set({ error }),
      reset: () => set({
        points: [],
        isGenerating: false,
        progress: 0,
        error: null,
      }),
    }),
    { name: 'PuzzleStore' }
  )
);
```

### 4.3. ì£¼ìš” ì»´í¬ë„ŒíŠ¸

#### 4.3.1. ImageUploader

```typescript
// components/upload/ImageUploader.tsx

'use client';

import { useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useImageStore } from '@/stores/useImageStore';
import { useDropzone } from 'react-dropzone';

export default function ImageUploader() {
  const router = useRouter();
  const { setImage, isTooLarge } = useImageStore();

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    try {
      await setImage(file);
      router.push('/editor');
    } catch (error) {
      console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
    }
  }, [setImage, router]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/jpeg': ['.jpg', '.jpeg'],
      'image/png': ['.png'],
    },
    maxSize: 5 * 1024 * 1024, // 5MB
    multiple: false,
  });

  return (
    <div
      {...getRootProps()}
      className={`
        border-2 border-dashed rounded-xl p-16 
        text-center cursor-pointer transition-all
        ${isDragActive 
          ? 'border-blue-500 bg-blue-50 scale-105' 
          : 'border-gray-300 hover:border-gray-400'
        }
      `}
    >
      <input {...getInputProps()} />
      
      <div className="space-y-4">
        <div className="text-8xl">ğŸ“·</div>
        
        {isDragActive ? (
          <p className="text-xl font-medium">ì—¬ê¸°ì— ë†“ìœ¼ì„¸ìš”!</p>
        ) : (
          <>
            <p className="text-xl font-medium">
              ì‚¬ì§„ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”
            </p>
            <p className="text-sm text-gray-500">
              JPG, PNG íŒŒì¼ ì§€ì› (ìµœëŒ€ 5MB)
            </p>
          </>
        )}
      </div>
    </div>
  );
}
```

#### 4.3.2. PuzzleCanvas

```typescript
// components/preview/PuzzleCanvas.tsx

'use client';

import { useEffect, useRef } from 'react';
import { usePuzzleStore } from '@/stores/usePuzzleStore';

interface Point {
  x: number;
  y: number;
  number: number;
}

export default function PuzzleCanvas() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { points, originalSize } = usePuzzleStore();

  useEffect(() => {
    if (!canvasRef.current || points.length === 0) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d')!;

    // A4 ë¹„ìœ¨ (210mm x 297mm â‰ˆ 1:1.414)
    const canvasWidth = 600;
    const canvasHeight = 848;
    
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // ë°°ê²½ í°ìƒ‰
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // ìŠ¤ì¼€ì¼ ê³„ì‚° (ì—¬ë°± í¬í•¨)
    const margin = 50;
    const availableWidth = canvasWidth - 2 * margin;
    const availableHeight = canvasHeight - 2 * margin;
    
    const scale = Math.min(
      availableWidth / originalSize.width,
      availableHeight / originalSize.height
    );

    // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ì˜¤í”„ì…‹
    const scaledWidth = originalSize.width * scale;
    const scaledHeight = originalSize.height * scale;
    const offsetX = (canvasWidth - scaledWidth) / 2;
    const offsetY = (canvasHeight - scaledHeight) / 2;

    // ì  ê·¸ë¦¬ê¸°
    points.forEach((point) => {
      const x = point.x * scale + offsetX;
      const y = point.y * scale + offsetY;

      // ì  (ì›)
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fill();

      // ë²ˆí˜¸
      ctx.font = 'bold 14px Arial';
      ctx.fillStyle = 'black';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText(point.number.toString(), x + 8, y - 5);

      // 1ë²ˆ ì ì€ ë¹¨ê°„ ì›ìœ¼ë¡œ ê°•ì¡°
      if (point.number === 1) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, 2 * Math.PI);
        ctx.stroke();
      }
    });

  }, [points, originalSize]);

  if (points.length === 0) {
    return null;
  }

  return (
    <div className="border rounded-lg overflow-hidden shadow-lg bg-white">
      <canvas ref={canvasRef} className="w-full h-auto" />
    </div>
  );
}
```

---

## 5. ì´ë¯¸ì§€ ì²˜ë¦¬ ì•Œê³ ë¦¬ì¦˜

### 5.1. ë©”ì¸ íŒŒì´í”„ë¼ì¸

> âš ï¸ **ì¤‘ìš”**: ì•„ë˜ ì½”ë“œëŠ” **Web Worker ë‚´ë¶€ì—ì„œ ì‹¤í–‰**ë©ë‹ˆë‹¤.
> DOM APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ OffscreenCanvasì™€ ImageBitmapì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

```typescript
// lib/image-processing/index.ts (Web Worker ì „ìš©)

import { grayscaleConversion } from './grayscale';
import { cannyEdgeDetection } from './edge-detection';
import { extractContours } from './contour-extraction';
import { placePoints } from './point-placement';
import { assignNumbers } from './numbering';

export interface ProcessingOptions {
  difficulty: number; // 0-100
  startPosition: 'top-left' | 'top-right' | 'center';
  onProgress?: (progress: number, message: string) => void;
}

export interface Point {
  x: number;
  y: number;
  number: number;
}

export async function processImageToPuzzle(
  imageDataUrl: string,
  options: ProcessingOptions
): Promise<{ points: Point[]; originalSize: { width: number; height: number } }> {
  const { difficulty, startPosition, onProgress } = options;

  // 1. ì´ë¯¸ì§€ ë¡œë“œ (Worker í™˜ê²½ì—ì„œ ImageBitmap ì‚¬ìš©)
  onProgress?.(10, 'ì´ë¯¸ì§€ ë¡œë“œ ì¤‘...');
  const img = await loadImageInWorker(imageDataUrl);
  const originalSize = { width: img.width, height: img.height };

  // 2. OffscreenCanvasì— ê·¸ë¦¬ê¸°
  onProgress?.(20, 'ì´ë¯¸ì§€ ì¤€ë¹„ ì¤‘...');

  // í¬ê¸° ì œí•œ (ì„±ëŠ¥ ìµœì í™”)
  const maxSize = 1000;
  const scale = Math.min(1, maxSize / Math.max(img.width, img.height));

  const canvas = new OffscreenCanvas(
    Math.floor(img.width * scale),
    Math.floor(img.height * scale)
  );
  const ctx = canvas.getContext('2d')!;

  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // 3. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
  onProgress?.(30, 'ì´ë¯¸ì§€ ë¶„ì„ ì¤‘...');
  const grayData = grayscaleConversion(imageData);

  // 4. Canny ì—£ì§€ ê²€ì¶œ
  onProgress?.(50, 'ìœ¤ê³½ ì°¾ëŠ” ì¤‘...');
  const edgeData = cannyEdgeDetection(grayData);

  // 5. ìœ¤ê³½ì„  ì¶”ì¶œ (ê°€ì¥ í° ìœ¤ê³½ì„  1ê°œë§Œ)
  onProgress?.(60, 'ì„  ì¶”ì¶œ ì¤‘...');
  const contours = extractContours(edgeData);

  // 6. ì  ë°°ì¹˜ (Douglas-Peucker ê°„ì†Œí™”)
  onProgress?.(70, 'ì  ë°°ì¹˜ ì¤‘...');
  const rawPoints = placePoints(contours, difficulty);

  // 7. ë²ˆí˜¸ ë§¤ê¸°ê¸° (ë°°ì—´ íšŒì „ìœ¼ë¡œ ì‹œì‘ì  ì„¤ì •)
  onProgress?.(90, 'ë²ˆí˜¸ ë§¤ê¸°ëŠ” ì¤‘...');
  const points = assignNumbers(rawPoints, startPosition);

  onProgress?.(100, 'ì™„ë£Œ!');

  // ì›ë³¸ í¬ê¸°ë¡œ ì¢Œí‘œ ìŠ¤ì¼€ì¼ ë³µì›
  const scaledPoints = points.map(p => ({
    ...p,
    x: p.x / scale,
    y: p.y / scale,
  }));

  return { points: scaledPoints, originalSize };
}

// Worker í™˜ê²½ì—ì„œ ì´ë¯¸ì§€ ë¡œë“œ (ImageBitmap ì‚¬ìš©)
function loadImageInWorker(dataUrl: string): Promise<ImageBitmap> {
  return fetch(dataUrl)
    .then(res => res.blob())
    .then(blob => createImageBitmap(blob));
}
```

### 5.2. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜

```typescript
// lib/image-processing/grayscale.ts

export function grayscaleConversion(imageData: ImageData): ImageData {
  const { data, width, height } = imageData;
  const grayData = new ImageData(width, height);

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];

    // Luminosity ë°©ë²• (ì¸ê°„ ì‹œê°ì— ìµœì í™”)
    const gray = 0.299 * r + 0.587 * g + 0.114 * b;

    grayData.data[i] = gray;
    grayData.data[i + 1] = gray;
    grayData.data[i + 2] = gray;
    grayData.data[i + 3] = 255; // ì•ŒíŒŒ ì±„ë„
  }

  return grayData;
}
```

### 5.3. Canny ì—£ì§€ ê²€ì¶œ

**ì¤‘ìš”**: Sobel í•„í„° ëŒ€ì‹  Canny ì—£ì§€ ê²€ì¶œì„ ì‚¬ìš©í•©ë‹ˆë‹¤. Sobelì€ ëˆˆ, ì½”, ì… ë“± **ëª¨ë“  ë‚´ë¶€ ë””í…Œì¼**ì„ ê²€ì¶œí•˜ì—¬ 4ì‚´ ì•„ì´ìš© í¼ì¦ì—ëŠ” ë¶€ì í•©í•©ë‹ˆë‹¤. CannyëŠ” ë…¸ì´ì¦ˆë¥¼ ì œê±°í•˜ê³  **ì£¼ìš” ì™¸ê³½ì„ ë§Œ** ê°•ì¡°í•©ë‹ˆë‹¤.

```typescript
// lib/image-processing/edge-detection.ts

export function cannyEdgeDetection(imageData: ImageData): ImageData {
  const { data, width, height } = imageData;

  // 1. Gaussian Blur (ë…¸ì´ì¦ˆ ì œê±°)
  const blurred = gaussianBlur(imageData, 1.4);

  // 2. Sobel ê·¸ë¼ë””ì–¸íŠ¸ ê³„ì‚°
  const { magnitude, direction } = computeGradient(blurred);

  // 3. Non-maximum Suppression (ê°€ì¥ ê°•í•œ ì—£ì§€ë§Œ ë‚¨ê¹€)
  const suppressed = nonMaxSuppression(magnitude, direction, width, height);

  // 4. Double Threshold (ê°•í•œ ì—£ì§€ / ì•½í•œ ì—£ì§€ êµ¬ë¶„)
  const thresholded = doubleThreshold(suppressed, width, height, 50, 100);

  // 5. Edge Tracking by Hysteresis (ì—°ê²°ëœ ì—£ì§€ë§Œ ìœ ì§€)
  const edges = edgeTrackingHysteresis(thresholded, width, height);

  return edges;
}

function gaussianBlur(imageData: ImageData, sigma: number): ImageData {
  // 5x5 Gaussian ì»¤ë„
  const { data, width, height } = imageData;
  const blurred = new ImageData(width, height);

  const kernel = [
    [2, 4, 5, 4, 2],
    [4, 9, 12, 9, 4],
    [5, 12, 15, 12, 5],
    [4, 9, 12, 9, 4],
    [2, 4, 5, 4, 2],
  ];

  const kernelSum = 159;

  for (let y = 2; y < height - 2; y++) {
    for (let x = 2; x < width - 2; x++) {
      let sum = 0;

      for (let ky = 0; ky < 5; ky++) {
        for (let kx = 0; kx < 5; kx++) {
          const pixelIndex = ((y + ky - 2) * width + (x + kx - 2)) * 4;
          sum += data[pixelIndex] * kernel[ky][kx];
        }
      }

      const blurredValue = sum / kernelSum;
      const index = (y * width + x) * 4;
      blurred.data[index] = blurredValue;
      blurred.data[index + 1] = blurredValue;
      blurred.data[index + 2] = blurredValue;
      blurred.data[index + 3] = 255;
    }
  }

  return blurred;
}

function computeGradient(imageData: ImageData): {
  magnitude: Float32Array;
  direction: Float32Array;
} {
  const { data, width, height } = imageData;
  const magnitude = new Float32Array(width * height);
  const direction = new Float32Array(width * height);

  const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let gx = 0;
      let gy = 0;

      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const pixelIndex = ((y + ky) * width + (x + kx)) * 4;
          const gray = data[pixelIndex];
          const kernelIndex = (ky + 1) * 3 + (kx + 1);

          gx += gray * sobelX[kernelIndex];
          gy += gray * sobelY[kernelIndex];
        }
      }

      const index = y * width + x;
      magnitude[index] = Math.sqrt(gx * gx + gy * gy);
      direction[index] = Math.atan2(gy, gx);
    }
  }

  return { magnitude, direction };
}

function nonMaxSuppression(
  magnitude: Float32Array,
  direction: Float32Array,
  width: number,
  height: number
): Float32Array {
  const result = new Float32Array(width * height);

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const index = y * width + x;
      const angle = direction[index];
      const mag = magnitude[index];

      // ê·¸ë¼ë””ì–¸íŠ¸ ë°©í–¥ì— ë”°ë¼ ì´ì›ƒ í”½ì…€ ì„ íƒ
      let neighbor1, neighbor2;

      if ((angle >= -Math.PI / 8 && angle < Math.PI / 8) ||
          (angle >= 7 * Math.PI / 8 || angle < -7 * Math.PI / 8)) {
        neighbor1 = magnitude[index - 1];
        neighbor2 = magnitude[index + 1];
      } else if (angle >= Math.PI / 8 && angle < 3 * Math.PI / 8) {
        neighbor1 = magnitude[index - width + 1];
        neighbor2 = magnitude[index + width - 1];
      } else if (angle >= 3 * Math.PI / 8 && angle < 5 * Math.PI / 8) {
        neighbor1 = magnitude[index - width];
        neighbor2 = magnitude[index + width];
      } else {
        neighbor1 = magnitude[index - width - 1];
        neighbor2 = magnitude[index + width + 1];
      }

      // ìµœëŒ€ê°’ì´ë©´ ìœ ì§€, ì•„ë‹ˆë©´ ì œê±°
      if (mag >= neighbor1 && mag >= neighbor2) {
        result[index] = mag;
      } else {
        result[index] = 0;
      }
    }
  }

  return result;
}

function doubleThreshold(
  magnitude: Float32Array,
  width: number,
  height: number,
  lowThreshold: number,
  highThreshold: number
): Uint8Array {
  const result = new Uint8Array(width * height);

  for (let i = 0; i < magnitude.length; i++) {
    const mag = magnitude[i];

    if (mag >= highThreshold) {
      result[i] = 2; // ê°•í•œ ì—£ì§€
    } else if (mag >= lowThreshold) {
      result[i] = 1; // ì•½í•œ ì—£ì§€
    } else {
      result[i] = 0; // ì—£ì§€ ì•„ë‹˜
    }
  }

  return result;
}

function edgeTrackingHysteresis(
  thresholded: Uint8Array,
  width: number,
  height: number
): ImageData {
  const result = new ImageData(width, height);
  const visited = new Uint8Array(width * height);

  // ê°•í•œ ì—£ì§€ë¶€í„° ì‹œì‘í•˜ì—¬ ì—°ê²°ëœ ì•½í•œ ì—£ì§€ ì¶”ì 
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const index = y * width + x;

      if (thresholded[index] === 2 && visited[index] === 0) {
        // ê°•í•œ ì—£ì§€ë¶€í„° DFSë¡œ ì—°ê²°ëœ ì•½í•œ ì—£ì§€ ì°¾ê¸°
        traceEdge(thresholded, visited, result.data, x, y, width, height);
      }
    }
  }

  return result;
}

function traceEdge(
  thresholded: Uint8Array,
  visited: Uint8Array,
  output: Uint8ClampedArray,
  x: number,
  y: number,
  width: number,
  height: number
): void {
  const stack: Array<{ x: number; y: number }> = [{ x, y }];

  while (stack.length > 0) {
    const { x: cx, y: cy } = stack.pop()!;
    const index = cy * width + cx;

    if (cx < 0 || cx >= width || cy < 0 || cy >= height ||
        visited[index] === 1 || thresholded[index] === 0) {
      continue;
    }

    visited[index] = 1;

    // ì—£ì§€ë¡œ í‘œì‹œ
    const pixelIndex = index * 4;
    output[pixelIndex] = 255;
    output[pixelIndex + 1] = 255;
    output[pixelIndex + 2] = 255;
    output[pixelIndex + 3] = 255;

    // 8ë°©í–¥ ì´ì›ƒ íƒìƒ‰
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        stack.push({ x: cx + dx, y: cy + dy });
      }
    }
  }
}
```

### 5.4. ìœ¤ê³½ì„  ì¶”ì¶œ

**ì¤‘ìš”**: ëª¨ë“  ìœ¤ê³½ì„ ì„ ì¶”ì¶œí•˜ì§€ ì•Šê³ , **ê°€ì¥ í° ìœ¤ê³½ì„  1ê°œë§Œ** ì„ íƒí•©ë‹ˆë‹¤. ì´ê²ƒì´ ìºë¦­í„°ì˜ ì£¼ ì™¸ê³½ì„ ì¼ í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤. ì—¬ëŸ¬ ê°œë¥¼ ì‚¬ìš©í•˜ë©´ ë‚´ë¶€ ë””í…Œì¼(ëˆˆ, ì½” ë“±)ê¹Œì§€ ì ìœ¼ë¡œ ë³€í™˜ë˜ì–´ í¼ì¦ì´ ë³µì¡í•´ì§‘ë‹ˆë‹¤.

```typescript
// lib/image-processing/contour-extraction.ts

export interface Contour {
  points: Array<{ x: number; y: number }>;
  length: number; // ìœ¤ê³½ì„ ì˜ ì´ ê¸¸ì´ (ì ì˜ ê°œìˆ˜)
}

export function extractContours(edgeData: ImageData): Contour[] {
  const { data, width, height } = edgeData;

  // 1. ì´ì§„í™” (Canny ê²°ê³¼ëŠ” ì´ë¯¸ ì´ì§„í™”ë¨)
  const binaryData = new Uint8Array(width * height);

  for (let i = 0; i < data.length; i += 4) {
    binaryData[i / 4] = data[i] > 128 ? 1 : 0;
  }

  // 2. ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ ì°¾ê¸°
  const visited = new Uint8Array(width * height);
  const contours: Contour[] = [];

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const index = y * width + x;

      if (binaryData[index] === 1 && visited[index] === 0) {
        const contour = traceContour(binaryData, visited, width, height, x, y);

        // ìµœì†Œ í¬ê¸° í•„í„°ë§ (ë„ˆë¬´ ì‘ì€ ë…¸ì´ì¦ˆ ì œì™¸)
        if (contour.points.length > 50) {
          contours.push(contour);
        }
      }
    }
  }

  // 3. ê¸¸ì´ ìˆœìœ¼ë¡œ ì •ë ¬ (ê¸´ ê²ƒë¶€í„°)
  contours.sort((a, b) => b.length - a.length);

  // â­ í•µì‹¬: ê°€ì¥ ê¸´ ìœ¤ê³½ì„  1ê°œë§Œ ë°˜í™˜
  // ì´ê²ƒì´ ìºë¦­í„°ì˜ ì£¼ ì™¸ê³½ì„ ì…ë‹ˆë‹¤.
  return contours.length > 0 ? [contours[0]] : [];
}

function traceContour(
  binaryData: Uint8Array,
  visited: Uint8Array,
  width: number,
  height: number,
  startX: number,
  startY: number
): Contour {
  const points: Array<{ x: number; y: number }> = [];

  // ìœ¤ê³½ì„ ì„ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ì¶”ì  (ìˆœì„œ ë³´ì¡´)
  let x = startX;
  let y = startY;
  let direction = 0; // ì‹œì‘ ë°©í–¥ (ë™ìª½)

  const directions = [
    { dx: 1, dy: 0 },   // ë™
    { dx: 1, dy: 1 },   // ë‚¨ë™
    { dx: 0, dy: 1 },   // ë‚¨
    { dx: -1, dy: 1 },  // ë‚¨ì„œ
    { dx: -1, dy: 0 },  // ì„œ
    { dx: -1, dy: -1 }, // ë¶ì„œ
    { dx: 0, dy: -1 },  // ë¶
    { dx: 1, dy: -1 },  // ë¶ë™
  ];

  const maxIterations = width * height; // ë¬´í•œ ë£¨í”„ ë°©ì§€
  let iterations = 0;

  do {
    const index = y * width + x;
    visited[index] = 1;
    points.push({ x, y });

    // ë‹¤ìŒ ê²½ê³„ì  ì°¾ê¸° (ì‹œê³„ ë°©í–¥)
    let found = false;

    for (let i = 0; i < 8; i++) {
      const checkDir = (direction + 7 + i) % 8; // ë°˜ì‹œê³„ë¡œ ì‹œì‘
      const { dx, dy } = directions[checkDir];
      const nx = x + dx;
      const ny = y + dy;

      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
        const nIndex = ny * width + nx;

        if (binaryData[nIndex] === 1) {
          x = nx;
          y = ny;
          direction = checkDir;
          found = true;
          break;
        }
      }
    }

    if (!found) break;

    iterations++;
    if (iterations > maxIterations) break;

    // ì‹œì‘ì ìœ¼ë¡œ ëŒì•„ì˜¤ë©´ ì¢…ë£Œ
    if (points.length > 1 && x === startX && y === startY) {
      break;
    }
  } while (true);

  return { points, length: points.length };
}
```

### 5.5. Douglas-Peucker ì•Œê³ ë¦¬ì¦˜

```typescript
// lib/image-processing/douglas-peucker.ts

export function douglasPeucker(
  points: Array<{ x: number; y: number }>,
  epsilon: number
): Array<{ x: number; y: number }> {
  if (points.length <= 2) {
    return points;
  }

  // ì²« ì ê³¼ ë§ˆì§€ë§‰ ì  ì‚¬ì´ì˜ ì„ ë¶„ì—ì„œ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
  let maxDistance = 0;
  let maxIndex = 0;

  const start = points[0];
  const end = points[points.length - 1];

  for (let i = 1; i < points.length - 1; i++) {
    const distance = perpendicularDistance(points[i], start, end);
    
    if (distance > maxDistance) {
      maxDistance = distance;
      maxIndex = i;
    }
  }

  // ìµœëŒ€ ê±°ë¦¬ê°€ epsilonë³´ë‹¤ í¬ë©´ ì¬ê·€ì ìœ¼ë¡œ ë¶„í• 
  if (maxDistance > epsilon) {
    const leftPoints = douglasPeucker(points.slice(0, maxIndex + 1), epsilon);
    const rightPoints = douglasPeucker(points.slice(maxIndex), epsilon);

    // ë§ˆì§€ë§‰ ì  ì¤‘ë³µ ì œê±°
    return [...leftPoints.slice(0, -1), ...rightPoints];
  } else {
    // epsilonë³´ë‹¤ ì‘ìœ¼ë©´ ì²« ì ê³¼ ë§ˆì§€ë§‰ ì ë§Œ ìœ ì§€
    return [start, end];
  }
}

function perpendicularDistance(
  point: { x: number; y: number },
  lineStart: { x: number; y: number },
  lineEnd: { x: number; y: number }
): number {
  const { x: px, y: py } = point;
  const { x: x1, y: y1 } = lineStart;
  const { x: x2, y: y2 } = lineEnd;

  const dx = x2 - x1;
  const dy = y2 - y1;

  // ì„ ë¶„ì˜ ê¸¸ì´ê°€ 0ì´ë©´ ì ê¹Œì§€ì˜ ê±°ë¦¬ ë°˜í™˜
  if (dx === 0 && dy === 0) {
    return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
  }

  // ìˆ˜ì§ ê±°ë¦¬ ê³„ì‚°
  const numerator = Math.abs(dy * px - dx * py + x2 * y1 - y2 * x1);
  const denominator = Math.sqrt(dx ** 2 + dy ** 2);

  return numerator / denominator;
}
```

### 5.6. ì  ë°°ì¹˜

```typescript
// lib/image-processing/point-placement.ts

import { douglasPeucker } from './douglas-peucker';
import type { Contour } from './contour-extraction';

export interface PlacedPoint {
  x: number;
  y: number;
  contourId: number;
}

export function placePoints(
  contours: Contour[],
  difficulty: number
): PlacedPoint[] {
  // ë‚œì´ë„ë¥¼ epsilonìœ¼ë¡œ ë³€í™˜
  // difficulty 0 (ì‰¬ì›€) â†’ epsilon 50 (ì  ì ìŒ)
  // difficulty 100 (ì–´ë ¤ì›€) â†’ epsilon 5 (ì  ë§ìŒ)
  const epsilon = 50 - (difficulty / 100) * 45;

  const allPoints: PlacedPoint[] = [];

  contours.forEach((contour, contourId) => {
    // Douglas-Peucker ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì  ë‹¨ìˆœí™”
    const simplifiedPoints = douglasPeucker(contour.points, epsilon);

    // PlacedPointë¡œ ë³€í™˜
    simplifiedPoints.forEach(point => {
      allPoints.push({
        x: point.x,
        y: point.y,
        contourId,
      });
    });
  });

  // ìµœì†Œ ê±°ë¦¬ ì œì•½ ì ìš© (ë²ˆí˜¸ê°€ ê²¹ì¹˜ì§€ ì•Šë„ë¡)
  const minDistance = 20; // í”½ì…€
  const filteredPoints = enforceMinDistance(allPoints, minDistance);

  return filteredPoints;
}

function enforceMinDistance(
  points: PlacedPoint[],
  minDistance: number
): PlacedPoint[] {
  if (points.length === 0) return points;

  const filtered: PlacedPoint[] = [points[0]];

  for (const point of points.slice(1)) {
    let isFarEnough = true;

    for (const existing of filtered) {
      const distance = Math.sqrt(
        (point.x - existing.x) ** 2 + (point.y - existing.y) ** 2
      );

      if (distance < minDistance) {
        isFarEnough = false;
        break;
      }
    }

    if (isFarEnough) {
      filtered.push(point);
    }
  }

  return filtered;
}
```

### 5.7. ë²ˆí˜¸ ë§¤ê¸°ê¸°

**ì¤‘ìš”**: Douglas-Peucker ì•Œê³ ë¦¬ì¦˜ì€ **ì›ë³¸ ìœ¤ê³½ì„ ì˜ ìˆœì„œë¥¼ ë³´ì¡´**í•©ë‹ˆë‹¤. ë”°ë¼ì„œ Nearest Neighbor ë°©ì‹ìœ¼ë¡œ ì¬ì •ë ¬í•˜ë©´ ì•ˆ ë©ë‹ˆë‹¤! ì‹œì‘ì ì˜ ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ì„œ ë°°ì—´ì„ íšŒì „(rotate)ì‹œí‚¤ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.

```typescript
// lib/image-processing/numbering.ts

import type { PlacedPoint } from './point-placement';

export interface NumberedPoint {
  x: number;
  y: number;
  number: number;
}

export function assignNumbers(
  points: PlacedPoint[],
  startPosition: 'top-left' | 'top-right' | 'center'
): NumberedPoint[] {
  if (points.length === 0) return [];

  // 1. ì‹œì‘ì ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
  const startIndex = findStartPointIndex(points, startPosition);

  // 2. ë°°ì—´ì„ ì‹œì‘ì ë¶€í„° ìˆœí™˜í•˜ë„ë¡ ì¬ì •ë ¬
  // [A, B, C, D, E]ì—ì„œ ì‹œì‘ì ì´ C(index=2)ë¼ë©´
  // [C, D, E, A, B]ë¡œ ë³€í™˜
  const reordered = [
    ...points.slice(startIndex),
    ...points.slice(0, startIndex),
  ];

  // 3. ìˆœì°¨ì ìœ¼ë¡œ ë²ˆí˜¸ ë§¤ê¸°ê¸°
  return reordered.map((point, index) => ({
    x: point.x,
    y: point.y,
    number: index + 1,
  }));
}

function findStartPointIndex(
  points: PlacedPoint[],
  startPosition: 'top-left' | 'top-right' | 'center'
): number {
  if (startPosition === 'top-left') {
    // ì¢Œìƒë‹¨ì— ê°€ì¥ ê°€ê¹Œìš´ ì ì˜ ì¸ë±ìŠ¤
    return points.reduce(
      (minIdx, point, idx) =>
        point.x + point.y < points[minIdx].x + points[minIdx].y ? idx : minIdx,
      0
    );
  } else if (startPosition === 'top-right') {
    // ìš°ìƒë‹¨ì— ê°€ì¥ ê°€ê¹Œìš´ ì ì˜ ì¸ë±ìŠ¤
    const maxX = Math.max(...points.map(p => p.x));
    return points.reduce(
      (minIdx, point, idx) =>
        (maxX - point.x) + point.y < (maxX - points[minIdx].x) + points[minIdx].y
          ? idx
          : minIdx,
      0
    );
  } else {
    // ì¤‘ì•™ì— ê°€ì¥ ê°€ê¹Œìš´ ì ì˜ ì¸ë±ìŠ¤
    const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
    const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

    return points.reduce((minIdx, point, idx) => {
      const distPoint = (point.x - centerX) ** 2 + (point.y - centerY) ** 2;
      const distMin =
        (points[minIdx].x - centerX) ** 2 + (points[minIdx].y - centerY) ** 2;
      return distPoint < distMin ? idx : minIdx;
    }, 0);
  }
}
```

---

## 6. ë°ì´í„° ëª¨ë¸

### 6.1. TypeScript íƒ€ì… ì •ì˜

```typescript
// types/image.ts

export interface ImageFile {
  file: File;
  dataUrl: string;
  width: number;
  height: number;
  name: string;
  size: number;
}

export interface ImageValidation {
  isValid: boolean;
  errors: string[];
}
```

```typescript
// types/puzzle.ts

export interface PuzzlePoint {
  x: number;
  y: number;
  number: number;
}

export interface PuzzleConfig {
  difficulty: number; // 0-100
  startPosition: 'top-left' | 'top-right' | 'center';
}

export interface GeneratedPuzzle {
  points: PuzzlePoint[];
  originalSize: {
    width: number;
    height: number;
  };
  config: PuzzleConfig;
  generatedAt: Date;
}
```

---

## 7. ì„±ëŠ¥ ìµœì í™”

### 7.1. ì´ë¯¸ì§€ ì²˜ë¦¬ ìµœì í™”

**âš ï¸ Web Worker ì‚¬ìš© (MVP í•„ìˆ˜) + iOS Safari í´ë°±**

Canny ì—£ì§€ ê²€ì¶œì€ 5ë‹¨ê³„ ì²˜ë¦¬ë¡œ **ë§¤ìš° ë¬´ê²ìŠµë‹ˆë‹¤**. 1000x1000px ì´ë¯¸ì§€ë¥¼ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬í•˜ë©´ UIê°€ 3~5ì´ˆ ì´ìƒ ë©‰ë‹ˆë‹¤. F-03ì˜ "5ì´ˆ ì´ë‚´ ë¯¸ë¦¬ë³´ê¸°" SLAë¥¼ ì§€í‚¤ë ¤ë©´ **Web Workerê°€ MVPì— í•„ìˆ˜**ì…ë‹ˆë‹¤.

**ê·¸ëŸ¬ë‚˜** iOS Safari 15.x ì´í•˜ì—ì„œ Workerì˜ OffscreenCanvasê°€ ë¯¸ì§€ì›ë˜ë¯€ë¡œ, ë©”ì¸ ìŠ¤ë ˆë“œ í´ë°±ì´ í•„ìˆ˜ì…ë‹ˆë‹¤.

**Feature Detection (ë¸Œë¼ìš°ì € ì§€ì› ê°ì§€)**

```typescript
// lib/utils/feature-detection.ts

export interface FeatureSupport {
  offscreenCanvas: boolean;
  createImageBitmap: boolean;
  webWorker: boolean;
  canUseWorkerPipeline: boolean;
}

export function detectFeatures(): FeatureSupport {
  const offscreenCanvas = typeof OffscreenCanvas !== 'undefined';
  const createImageBitmap = typeof self.createImageBitmap === 'function';
  const webWorker = typeof Worker !== 'undefined';

  return {
    offscreenCanvas,
    createImageBitmap,
    webWorker,
    // Worker íŒŒì´í”„ë¼ì¸ ì‚¬ìš© ê°€ëŠ¥ ì¡°ê±´: 3ê°€ì§€ ëª¨ë‘ ì§€ì›
    canUseWorkerPipeline: offscreenCanvas && createImageBitmap && webWorker,
  };
}

export function getRecommendedStrategy(): 'worker' | 'main-thread' {
  const features = detectFeatures();

  if (features.canUseWorkerPipeline) {
    return 'worker';
  }

  // iOS Safari ë“± ë¯¸ì§€ì› ë¸Œë¼ìš°ì €
  console.warn('OffscreenCanvas not supported, falling back to main thread');
  return 'main-thread';
}
```

**Worker êµ¬í˜„ (OffscreenCanvas ì‚¬ìš©)**

```typescript
// workers/image-processor.worker.ts

import { grayscaleConversion } from '../lib/image-processing/grayscale';
import { cannyEdgeDetection } from '../lib/image-processing/edge-detection';
import { extractContours } from '../lib/image-processing/contour-extraction';
import { placePoints } from '../lib/image-processing/point-placement';
import { assignNumbers } from '../lib/image-processing/numbering';

// Workerì—ì„œ ì‹¤í–‰ë˜ëŠ” ë©”ì¸ í•¨ìˆ˜
self.onmessage = async (e: MessageEvent) => {
  const { imageDataUrl, options } = e.data;

  try {
    // 1. ì´ë¯¸ì§€ ë¡œë“œ (ImageBitmap ì‚¬ìš©)
    self.postMessage({ type: 'progress', progress: 10, message: 'ì´ë¯¸ì§€ ë¡œë“œ ì¤‘...' });
    const img = await loadImageInWorker(imageDataUrl);
    const originalSize = { width: img.width, height: img.height };

    // 2. OffscreenCanvasì— ê·¸ë¦¬ê¸°
    self.postMessage({ type: 'progress', progress: 20, message: 'ì´ë¯¸ì§€ ì¤€ë¹„ ì¤‘...' });
    const imageData = getImageData(img);

    // 3. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
    self.postMessage({ type: 'progress', progress: 30, message: 'ì´ë¯¸ì§€ ë¶„ì„ ì¤‘...' });
    const grayData = grayscaleConversion(imageData);

    // 4. Canny ì—£ì§€ ê²€ì¶œ (ë¬´ê±°ìš´ ì‘ì—…!)
    self.postMessage({ type: 'progress', progress: 50, message: 'ìœ¤ê³½ ì°¾ëŠ” ì¤‘...' });
    const edgeData = cannyEdgeDetection(grayData);

    // 5. ìœ¤ê³½ì„  ì¶”ì¶œ
    self.postMessage({ type: 'progress', progress: 60, message: 'ì„  ì¶”ì¶œ ì¤‘...' });
    const contours = extractContours(edgeData);

    // 6. ì  ë°°ì¹˜
    self.postMessage({ type: 'progress', progress: 70, message: 'ì  ë°°ì¹˜ ì¤‘...' });
    const rawPoints = placePoints(contours, options.difficulty);

    // 7. ë²ˆí˜¸ ë§¤ê¸°ê¸°
    self.postMessage({ type: 'progress', progress: 90, message: 'ë²ˆí˜¸ ë§¤ê¸°ëŠ” ì¤‘...' });
    const points = assignNumbers(rawPoints, options.startPosition);

    self.postMessage({ type: 'progress', progress: 100, message: 'ì™„ë£Œ!' });

    // ê²°ê³¼ ë°˜í™˜
    self.postMessage({
      type: 'success',
      result: { points, originalSize }
    });
  } catch (error) {
    self.postMessage({
      type: 'error',
      error: error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'
    });
  }
};

// Worker ë‚´ë¶€ì—ì„œ ì´ë¯¸ì§€ ë¡œë“œ
function loadImageInWorker(dataUrl: string): Promise<ImageBitmap> {
  return fetch(dataUrl)
    .then(res => res.blob())
    .then(blob => createImageBitmap(blob));
}

// ImageBitmapì„ ImageDataë¡œ ë³€í™˜
function getImageData(img: ImageBitmap): ImageData {
  const canvas = new OffscreenCanvas(img.width, img.height);
  const ctx = canvas.getContext('2d')!;
  ctx.drawImage(img, 0, 0);
  return ctx.getImageData(0, 0, img.width, img.height);
}
```

**ë©”ì¸ ìŠ¤ë ˆë“œ í´ë°± êµ¬í˜„**

```typescript
// lib/image-processing/main-thread-processor.ts

import { grayscaleConversion } from './grayscale';
import { cannyEdgeDetection } from './edge-detection';
import { extractContours } from './contour-extraction';
import { placePoints } from './point-placement';
import { assignNumbers } from './numbering';

export async function processInMainThread(
  imageDataUrl: string,
  options: { difficulty: number; startPosition: string },
  onProgress?: (progress: number, message: string) => void
) {
  // 1. HTMLImageElement ë¡œë“œ
  onProgress?.(10, 'ì´ë¯¸ì§€ ë¡œë“œ ì¤‘...');
  const img = await loadImageInMainThread(imageDataUrl);
  const originalSize = { width: img.width, height: img.height };

  // 2. document.createElement('canvas') ì‚¬ìš©
  onProgress?.(20, 'ì´ë¯¸ì§€ ì¤€ë¹„ ì¤‘...');
  const canvas = document.createElement('canvas');
  const maxSize = 1000;
  const scale = Math.min(1, maxSize / Math.max(img.width, img.height));

  canvas.width = Math.floor(img.width * scale);
  canvas.height = Math.floor(img.height * scale);

  const ctx = canvas.getContext('2d')!;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // 3. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
  onProgress?.(30, 'ì´ë¯¸ì§€ ë¶„ì„ ì¤‘...');
  const grayData = grayscaleConversion(imageData);

  // 4. Canny ì—£ì§€ ê²€ì¶œ
  onProgress?.(50, 'ìœ¤ê³½ ì°¾ëŠ” ì¤‘...');
  const edgeData = cannyEdgeDetection(grayData);

  // 5. ìœ¤ê³½ì„  ì¶”ì¶œ (ê°€ì¥ í° ìœ¤ê³½ì„  1ê°œë§Œ)
  onProgress?.(60, 'ì„  ì¶”ì¶œ ì¤‘...');
  const contours = extractContours(edgeData);

  // 6. ì  ë°°ì¹˜ (Douglas-Peucker ê°„ì†Œí™”)
  onProgress?.(70, 'ì  ë°°ì¹˜ ì¤‘...');
  const rawPoints = placePoints(contours, options.difficulty);

  // 7. ë²ˆí˜¸ ë§¤ê¸°ê¸° (ë°°ì—´ íšŒì „ìœ¼ë¡œ ì‹œì‘ì  ì„¤ì •)
  onProgress?.(90, 'ë²ˆí˜¸ ë§¤ê¸°ëŠ” ì¤‘...');
  const points = assignNumbers(rawPoints, options.startPosition);

  onProgress?.(100, 'ì™„ë£Œ!');

  // ì›ë³¸ í¬ê¸°ë¡œ ì¢Œí‘œ ìŠ¤ì¼€ì¼ ë³µì›
  const scaledPoints = points.map(p => ({
    ...p,
    x: p.x / scale,
    y: p.y / scale,
  }));

  return { points: scaledPoints, originalSize };
}

function loadImageInMainThread(dataUrl: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}
```

**React Hook with Fallback (ìë™ ê°ì§€ + í´ë°±)**

```typescript
// hooks/usePuzzleGeneration.ts

import { useRef, useCallback, useState, useEffect } from 'react';
import { usePuzzleStore } from '@/stores/usePuzzleStore';
import { getRecommendedStrategy } from '@/lib/utils/feature-detection';
import { processInMainThread } from '@/lib/image-processing/main-thread-processor';

export function usePuzzleGeneration() {
  const workerRef = useRef<Worker | null>(null);
  const [strategy, setStrategy] = useState<'worker' | 'main-thread'>('worker');
  const [showWarning, setShowWarning] = useState(false);
  const { setPoints, setGenerating, setProgress, setError } = usePuzzleStore();

  // ë¸Œë¼ìš°ì € ê¸°ëŠ¥ ê°ì§€
  useEffect(() => {
    const detectedStrategy = getRecommendedStrategy();
    setStrategy(detectedStrategy);

    if (detectedStrategy === 'main-thread') {
      setShowWarning(true);
      console.warn('âš ï¸ iOS Safari detected: Using main-thread fallback (slower performance)');
    }
  }, []);

  const generatePuzzle = useCallback(async (
    imageDataUrl: string,
    options: { difficulty: number; startPosition: string }
  ) => {
    setGenerating(true);
    setError(null);
    setProgress(0);

    try {
      if (strategy === 'worker') {
        // Worker ê²½ë¡œ (Chrome, Firefox, Safari 16.4+)
        if (!workerRef.current) {
          workerRef.current = new Worker(
            new URL('../workers/image-processor.worker.ts', import.meta.url),
            { type: 'module' }
          );
        }

        const worker = workerRef.current;

        const result = await new Promise<any>((resolve, reject) => {
          worker.onmessage = (e: MessageEvent) => {
            const { type, progress, result, error } = e.data;

            if (type === 'progress') {
              setProgress(progress);
            } else if (type === 'success') {
              resolve(result);
            } else if (type === 'error') {
              reject(new Error(error));
            }
          };

          worker.onerror = (error) => {
            reject(error);
          };

          worker.postMessage({ imageDataUrl, options });
        });

        setPoints(result.points, result.originalSize);
      } else {
        // ë©”ì¸ ìŠ¤ë ˆë“œ í´ë°± (iOS Safari 15.x ì´í•˜)
        const result = await processInMainThread(
          imageDataUrl,
          options,
          (progress, message) => setProgress(progress)
        );

        setPoints(result.points, result.originalSize);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'í¼ì¦ ìƒì„± ì‹¤íŒ¨');
    } finally {
      setGenerating(false);
    }
  }, [strategy, setPoints, setGenerating, setProgress, setError]);

  return { generatePuzzle, strategy, showWarning };
}
```

**UIì— ê²½ê³  í‘œì‹œ**

```typescript
// components/editor/ControlPanel.tsx

export function ControlPanel() {
  const { generatePuzzle, strategy, showWarning } = usePuzzleGeneration();

  return (
    <div>
      {showWarning && (
        <Alert variant="warning">
          âš ï¸ ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” í¼ì¦ ìƒì„± ì‹œ í™”ë©´ì´ ì ì‹œ ë©ˆì¶œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          ìµœì‹  Safari(16.4+) ë˜ëŠ” Chromeì„ ê¶Œì¥í•©ë‹ˆë‹¤.
        </Alert>
      )}

      {/* ... ë‚˜ë¨¸ì§€ UI */}
    </div>
  );
}
```

**ë©”ëª¨ë¦¬ ìµœì í™”**
- Canvas ì¬ì‚¬ìš©
- ImageData ì¦‰ì‹œ í•´ì œ
- í° ë°°ì—´ ì¡°ê¸° GC

```typescript
// ì¢‹ì€ ì˜ˆ (Worker í™˜ê²½)
function processImage(img: ImageBitmap) {
  const canvas = new OffscreenCanvas(img.width, img.height);
  const ctx = canvas.getContext('2d')!;

  // ì²˜ë¦¬...

  // ë©”ëª¨ë¦¬ í•´ì œ
  canvas.width = 0;
  canvas.height = 0;
}
```

### 7.2. ë²ˆë“¤ í¬ê¸° ìµœì í™”

**Next.js ì„¤ì •**
```typescript
// next.config.ts

import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // ìë™ ìµœì í™”
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // ì´ë¯¸ì§€ ìµœì í™”
  images: {
    formats: ['image/avif', 'image/webp'],
  },
  
  // ë²ˆë“¤ ë¶„ì„
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          commons: {
            name: 'commons',
            chunks: 'all',
            minChunks: 2,
          },
        },
      };
    }
    return config;
  },
};

export default nextConfig;
```

### 7.3. ë¡œë”© ì„±ëŠ¥

**ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…**
```typescript
// ë™ì  import
const PuzzleCanvas = dynamic(() => import('@/components/preview/PuzzleCanvas'), {
  loading: () => <LoadingSpinner />,
  ssr: false, // í´ë¼ì´ì–¸íŠ¸ ì „ìš©
});
```

**ì´ë¯¸ì§€ ë ˆì´ì§€ ë¡œë”©**
```typescript
<Image
  src="/example.jpg"
  alt="Example"
  loading="lazy"
  width={500}
  height={500}
/>
```

---

## 8. ë°°í¬ ì „ëµ

### 8.1. Vercel ë°°í¬ ì„¤ì •

**vercel.json**
```json
{
  "buildCommand": "pnpm build",
  "devCommand": "pnpm dev",
  "installCommand": "pnpm install",
  "framework": "nextjs",
  "regions": ["icn1"],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        }
      ]
    }
  ]
}
```

### 8.2. í™˜ê²½ ë³€ìˆ˜

```bash
# .env.local (ê°œë°œ)
NEXT_PUBLIC_ENVIRONMENT=development
NEXT_PUBLIC_ANALYTICS_ID=

# .env.production (í”„ë¡œë•ì…˜)
NEXT_PUBLIC_ENVIRONMENT=production
NEXT_PUBLIC_ANALYTICS_ID=G-XXXXXXXXXX
```

### 8.3. CI/CD

**GitHub Actions**
```yaml
# .github/workflows/deploy.yml

name: Deploy to Vercel

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Run tests
        run: pnpm test
      
      - name: Build
        run: pnpm build
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'
```

---

## 9. í…ŒìŠ¤íŠ¸ ì „ëµ

### 9.1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```typescript
// tests/unit/douglas-peucker.test.ts

import { describe, it, expect } from 'vitest';
import { douglasPeucker } from '@/lib/image-processing/douglas-peucker';

describe('douglasPeucker', () => {
  it('should simplify a straight line to 2 points', () => {
    const points = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 2, y: 0 },
      { x: 3, y: 0 },
    ];

    const result = douglasPeucker(points, 0.1);
    
    expect(result).toHaveLength(2);
    expect(result[0]).toEqual({ x: 0, y: 0 });
    expect(result[1]).toEqual({ x: 3, y: 0 });
  });

  it('should keep important points with low epsilon', () => {
    const points = [
      { x: 0, y: 0 },
      { x: 1, y: 1 },
      { x: 2, y: 0 },
    ];

    const result = douglasPeucker(points, 0.5);
    
    expect(result.length).toBeGreaterThan(2);
  });
});
```

### 9.2. E2E í…ŒìŠ¤íŠ¸

```typescript
// tests/e2e/puzzle-generation.spec.ts

import { test, expect } from '@playwright/test';

test.describe('Puzzle Generation Flow', () => {
  test('should generate puzzle from uploaded image', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // ì´ë¯¸ì§€ ì—…ë¡œë“œ
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles('./tests/fixtures/simple-circle.png');

    // í¸ì§‘ í˜ì´ì§€ë¡œ ì´ë™ í™•ì¸
    await expect(page).toHaveURL('/editor');

    // í¼ì¦ ìƒì„±
    await page.locator('button:has-text("í¼ì¦ ë§Œë“¤ê¸°")').click();

    // ë¡œë”© í™•ì¸
    await expect(page.locator('text=ì²˜ë¦¬ ì¤‘')).toBeVisible();

    // ë¯¸ë¦¬ë³´ê¸° í™•ì¸ (ìµœëŒ€ 15ì´ˆ ëŒ€ê¸°)
    await expect(page.locator('canvas')).toBeVisible({ timeout: 15000 });

    // ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ í™œì„±í™” í™•ì¸
    const downloadBtn = page.locator('button:has-text("PNG ë‹¤ìš´ë¡œë“œ")');
    await expect(downloadBtn).toBeEnabled();
  });
});
```

---